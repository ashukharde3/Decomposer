<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Decomposer: Relation Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Decomposer
   &#160;<span id="projectnumber">0.9</span>
   </div>
   <div id="projectbrief">A relational decomposition tool</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_relation-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Relation Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="class_relation.html" title="The Relation class that represents the relation entity. ">Relation</a> class that represents the relation entity.  
 <a href="class_relation.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="relation_8h_source.html">relation.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af4a36b464d672235cf91635f0816c95e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_relation.html#af4a36b464d672235cf91635f0816c95e">Normal</a> { <a class="el" href="class_relation.html#af4a36b464d672235cf91635f0816c95eac6128494e3d974929ae5ecd2e2df07ce">_2NF</a>, 
<a class="el" href="class_relation.html#af4a36b464d672235cf91635f0816c95ea0fbd388d0f5a49eea7bdeea548be03a3">_3NF</a>, 
<a class="el" href="class_relation.html#af4a36b464d672235cf91635f0816c95ea3e7f610cf0dcc22c6d1a3e654e7c16fa">_BCNF</a>
 }</td></tr>
<tr class="separator:af4a36b464d672235cf91635f0816c95e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae4e5fbc5744656e2949aa339a3a20809"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_relation.html#ae4e5fbc5744656e2949aa339a3a20809">Relation</a> (const string &amp;, const <a class="el" href="typedef_8h.html#aa234bdb39b1698c1d4955072cfb3195f">set_str</a> &amp;temp=*(new <a class="el" href="typedef_8h.html#aa234bdb39b1698c1d4955072cfb3195f">set_str</a>()), const <a class="el" href="typedef_8h.html#a49fdcf14d2faf54629fca98482b2dfb9">set_dep</a> &amp;t2=*(new <a class="el" href="typedef_8h.html#a49fdcf14d2faf54629fca98482b2dfb9">set_dep</a>()))</td></tr>
<tr class="separator:ae4e5fbc5744656e2949aa339a3a20809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae36aedb2fbe0084795d577a58ae44a3b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_relation.html#ae36aedb2fbe0084795d577a58ae44a3b">Relation</a> (const <a class="el" href="class_relation.html">Relation</a> &amp;orig)</td></tr>
<tr class="separator:ae36aedb2fbe0084795d577a58ae44a3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8bc5c349f9d98b15972fd0b09f341cc"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_relation.html#ad8bc5c349f9d98b15972fd0b09f341cc">~Relation</a> ()</td></tr>
<tr class="separator:ad8bc5c349f9d98b15972fd0b09f341cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4fd894562cf6b53bf207e6b5c1093ff"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_relation.html#ab4fd894562cf6b53bf207e6b5c1093ff">addAtributte</a> (const string &amp;)</td></tr>
<tr class="separator:ab4fd894562cf6b53bf207e6b5c1093ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb703bd9672bba59a283c86d3d718e5c"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_relation.html#aeb703bd9672bba59a283c86d3d718e5c">addAtributtes</a> (const <a class="el" href="typedef_8h.html#aa234bdb39b1698c1d4955072cfb3195f">set_str</a> &amp;)</td></tr>
<tr class="separator:aeb703bd9672bba59a283c86d3d718e5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a919e9f07b7f8bb2f1119b25f301d9f1c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_relation.html#a919e9f07b7f8bb2f1119b25f301d9f1c">removeAtributte</a> (const string &amp;)</td></tr>
<tr class="separator:a919e9f07b7f8bb2f1119b25f301d9f1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf6483df38b205939024c7f4e93bf890"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_relation.html#abf6483df38b205939024c7f4e93bf890">removeDependency</a> (const <a class="el" href="typedef_8h.html#aa234bdb39b1698c1d4955072cfb3195f">set_str</a> &amp;, const <a class="el" href="typedef_8h.html#aa234bdb39b1698c1d4955072cfb3195f">set_str</a> &amp;)</td></tr>
<tr class="separator:abf6483df38b205939024c7f4e93bf890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cee25dae94b1bb7ed1ce12592fbbd8b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_relation.html#a1cee25dae94b1bb7ed1ce12592fbbd8b">removeDependency</a> (const <a class="el" href="class_dependency.html">Dependency</a> &amp;)</td></tr>
<tr class="separator:a1cee25dae94b1bb7ed1ce12592fbbd8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba0be8b3cfe8d57a77ac0cf1bc2eee49"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_relation.html#aba0be8b3cfe8d57a77ac0cf1bc2eee49">addDependencies</a> (const <a class="el" href="typedef_8h.html#a49fdcf14d2faf54629fca98482b2dfb9">set_dep</a> &amp;, bool update=true)</td></tr>
<tr class="separator:aba0be8b3cfe8d57a77ac0cf1bc2eee49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b15b6309a27f5621039ae7e375bea95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="typedef_8h.html#ab78cecb3657d8a4377c1f9e4dba8778c">itr_dep</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_relation.html#a9b15b6309a27f5621039ae7e375bea95">addDependency</a> (const <a class="el" href="typedef_8h.html#aa234bdb39b1698c1d4955072cfb3195f">set_str</a> &amp;, const <a class="el" href="typedef_8h.html#aa234bdb39b1698c1d4955072cfb3195f">set_str</a> &amp;, bool update=true)</td></tr>
<tr class="separator:a9b15b6309a27f5621039ae7e375bea95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af67c3710d967393d2493c28aa6c84060"><td class="memItemLeft" align="right" valign="top"><a class="el" href="typedef_8h.html#ab78cecb3657d8a4377c1f9e4dba8778c">itr_dep</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_relation.html#af67c3710d967393d2493c28aa6c84060">findDepLHS</a> (const <a class="el" href="typedef_8h.html#aa234bdb39b1698c1d4955072cfb3195f">set_str</a> &amp;) const </td></tr>
<tr class="separator:af67c3710d967393d2493c28aa6c84060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5356ab1275c3f1dd82ab0a267d1dfabc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_relation.html#a5356ab1275c3f1dd82ab0a267d1dfabc">isNormal</a> (const <a class="el" href="class_relation.html#af4a36b464d672235cf91635f0816c95e">Relation::Normal</a> &amp;) const </td></tr>
<tr class="separator:a5356ab1275c3f1dd82ab0a267d1dfabc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade40c2bc16bac827eaddca39b3b8964d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_relation.html#ade40c2bc16bac827eaddca39b3b8964d">isDepAttribPresent</a> (const <a class="el" href="class_dependency.html">Dependency</a> &amp;) const </td></tr>
<tr class="separator:ade40c2bc16bac827eaddca39b3b8964d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c810ab6573fdd594a84e664bc21794a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_relation.html#a4c810ab6573fdd594a84e664bc21794a">isSuperkey</a> (const <a class="el" href="typedef_8h.html#aa234bdb39b1698c1d4955072cfb3195f">set_str</a> &amp;) const </td></tr>
<tr class="separator:a4c810ab6573fdd594a84e664bc21794a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d877107afd23e2e412011959de27740"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_relation.html#a0d877107afd23e2e412011959de27740">isPartialkey</a> (const <a class="el" href="typedef_8h.html#aa234bdb39b1698c1d4955072cfb3195f">set_str</a> &amp;) const </td></tr>
<tr class="separator:a0d877107afd23e2e412011959de27740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9ae78eb66d2950fea16dad1c21e62cd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_relation.html#ae9ae78eb66d2950fea16dad1c21e62cd">isPrime</a> (const <a class="el" href="typedef_8h.html#aa234bdb39b1698c1d4955072cfb3195f">set_str</a> &amp;) const </td></tr>
<tr class="separator:ae9ae78eb66d2950fea16dad1c21e62cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cc1fd687a99bbe395b7a51b7080e91c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="typedef_8h.html#aa234bdb39b1698c1d4955072cfb3195f">set_str</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_relation.html#a0cc1fd687a99bbe395b7a51b7080e91c">getClosure</a> (const <a class="el" href="typedef_8h.html#aa234bdb39b1698c1d4955072cfb3195f">set_str</a> &amp;) const </td></tr>
<tr class="separator:a0cc1fd687a99bbe395b7a51b7080e91c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad59a21ce2b07154ba6f14ce19e94bf9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="declaration_8h.html#a3205c77c822620c0f6dd4d42ccd70171">set_key</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_relation.html#ad59a21ce2b07154ba6f14ce19e94bf9e">getCandidatekey</a> (void) const </td></tr>
<tr class="separator:ad59a21ce2b07154ba6f14ce19e94bf9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3db61785cf2aa64c5ac7451bdc1a1aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="typedef_8h.html#a49fdcf14d2faf54629fca98482b2dfb9">set_dep</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_relation.html#ad3db61785cf2aa64c5ac7451bdc1a1aa">getViolation</a> (const <a class="el" href="class_relation.html#af4a36b464d672235cf91635f0816c95e">Relation::Normal</a> &amp;) const </td></tr>
<tr class="separator:ad3db61785cf2aa64c5ac7451bdc1a1aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5373e82dc8498648a6c75aa85f895bf4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="typedef_8h.html#a49fdcf14d2faf54629fca98482b2dfb9">set_dep</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_relation.html#a5373e82dc8498648a6c75aa85f895bf4">getMinimalCover</a> (bool details=false) const </td></tr>
<tr class="separator:a5373e82dc8498648a6c75aa85f895bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37f89ba2927b02631761e541fde9ff91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="typedef_8h.html#ae4f64e726e10cd561d68b42cf3a43e94">set_rel</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_relation.html#a37f89ba2927b02631761e541fde9ff91">decomposePreserving</a> (bool details=false) const </td></tr>
<tr class="separator:a37f89ba2927b02631761e541fde9ff91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af01e5bab69f13b1e1b80526de5594b0f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="typedef_8h.html#ae4f64e726e10cd561d68b42cf3a43e94">set_rel</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_relation.html#af01e5bab69f13b1e1b80526de5594b0f">decomposeNotPreserving</a> (bool details=false) const </td></tr>
<tr class="separator:af01e5bab69f13b1e1b80526de5594b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3c884586ee349da4f3c3e9a55d94f97"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_relation.html#af3c884586ee349da4f3c3e9a55d94f97">operator!=</a> (const <a class="el" href="class_relation.html">Relation</a> &amp;right) const </td></tr>
<tr class="separator:af3c884586ee349da4f3c3e9a55d94f97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a4c2acb958780bbf6fc5a52a456a9f6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_relation.html#a7a4c2acb958780bbf6fc5a52a456a9f6">operator==</a> (const <a class="el" href="class_relation.html">Relation</a> &amp;right) const </td></tr>
<tr class="separator:a7a4c2acb958780bbf6fc5a52a456a9f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaceeb923c5623a9f22cfb3f161b8a26c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_relation.html#aaceeb923c5623a9f22cfb3f161b8a26c">operator&lt;=</a> (const <a class="el" href="class_relation.html">Relation</a> &amp;right) const </td></tr>
<tr class="separator:aaceeb923c5623a9f22cfb3f161b8a26c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c7507f98a726b72f921f6ec940a0a3f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_relation.html#a3c7507f98a726b72f921f6ec940a0a3f">operator&gt;=</a> (const <a class="el" href="class_relation.html">Relation</a> &amp;right) const </td></tr>
<tr class="separator:a3c7507f98a726b72f921f6ec940a0a3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a234c8dfd0875f60b22799c587d46e0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_relation.html#a6a234c8dfd0875f60b22799c587d46e0">operator&gt;</a> (const <a class="el" href="class_relation.html">Relation</a> &amp;right) const </td></tr>
<tr class="separator:a6a234c8dfd0875f60b22799c587d46e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5dc18e0b5cb8937f87f1cb8593192e3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_relation.html#af5dc18e0b5cb8937f87f1cb8593192e3">operator&lt;</a> (const <a class="el" href="class_relation.html">Relation</a> &amp;right) const </td></tr>
<tr class="separator:af5dc18e0b5cb8937f87f1cb8593192e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c7aa8f1df884462856e4a1b4e05658b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_relation.html#a3c7aa8f1df884462856e4a1b4e05658b">clearDependencies</a> ()</td></tr>
<tr class="separator:a3c7aa8f1df884462856e4a1b4e05658b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2ac1a5f21fad67ea0d1370d653e2d67"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_relation.html#ad2ac1a5f21fad67ea0d1370d653e2d67">clearAttributes</a> ()</td></tr>
<tr class="separator:ad2ac1a5f21fad67ea0d1370d653e2d67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaed04d808db08b522023c833c31b87ea"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="typedef_8h.html#aa234bdb39b1698c1d4955072cfb3195f">set_str</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_relation.html#aaed04d808db08b522023c833c31b87ea">getAttributes</a> () const </td></tr>
<tr class="separator:aaed04d808db08b522023c833c31b87ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a569838107aebf43367d9c2c0dbc0d359"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="typedef_8h.html#a49fdcf14d2faf54629fca98482b2dfb9">set_dep</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_relation.html#a569838107aebf43367d9c2c0dbc0d359">getDependencies</a> () const </td></tr>
<tr class="separator:a569838107aebf43367d9c2c0dbc0d359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f2630997cefbc28c0abce228033fe92"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_relation.html#a3f2630997cefbc28c0abce228033fe92">getName</a> () const </td></tr>
<tr class="separator:a3f2630997cefbc28c0abce228033fe92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae98924c3d4ddf1e19a23403fcb35afe0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_relation.html#ae98924c3d4ddf1e19a23403fcb35afe0">setName</a> (const string name)</td></tr>
<tr class="separator:ae98924c3d4ddf1e19a23403fcb35afe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1d9a658374a2e84f82e117949b0a2a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="typedef_8h.html#ab78cecb3657d8a4377c1f9e4dba8778c">itr_dep</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_relation.html#ac1d9a658374a2e84f82e117949b0a2a2">addDependency</a> (const <a class="el" href="class_dependency.html">Dependency</a> &amp;, bool update=true)</td></tr>
<tr class="separator:ac1d9a658374a2e84f82e117949b0a2a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a080e2dc68964d24a791885961f55a322"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a080e2dc68964d24a791885961f55a322"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>relation_test</b></td></tr>
<tr class="separator:a080e2dc68964d24a791885961f55a322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae37f6c1025dfc13dc413a73b5b630963"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae37f6c1025dfc13dc413a73b5b630963"></a>
ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_relation.html#ae37f6c1025dfc13dc413a73b5b630963">operator&lt;&lt;</a> (ostream &amp;, const <a class="el" href="class_relation.html">Relation</a> &amp;)</td></tr>
<tr class="memdesc:ae37f6c1025dfc13dc413a73b5b630963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert <a class="el" href="class_relation.html" title="The Relation class that represents the relation entity. ">Relation</a> object into stream. <br /></td></tr>
<tr class="separator:ae37f6c1025dfc13dc413a73b5b630963"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="class_relation.html" title="The Relation class that represents the relation entity. ">Relation</a> class that represents the relation entity. </p>
<p>The <a class="el" href="class_relation.html" title="The Relation class that represents the relation entity. ">Relation</a> class contains the data member that represents the name of the <a class="el" href="class_relation.html" title="The Relation class that represents the relation entity. ">Relation</a>, the attribute set of the relation and a set of the functional dependency. The relation name will be represented by the string data member name. The attribute set will be represented by data member attributes - an object of set of string (set_str). The functional dependency set will represented by the data member dependencies - an object of set of <a class="el" href="class_dependency.html" title="The Dependency class that represents the functional dependency of the relation using the attribute se...">Dependency</a> objects (set_dep). The class also contains a enumeration data type Normal to identify the different normal form. It provides variety of the public method interface to modify the relation object and perform different operation on it. The class provides private read only access to the overloaded output operator &lt;&lt; for the output of the <a class="el" href="class_relation.html" title="The Relation class that represents the relation entity. ">Relation</a> object in the output stream. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="af4a36b464d672235cf91635f0816c95e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_relation.html#af4a36b464d672235cf91635f0816c95e">Relation::Normal</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The enumeration to identify different normal form. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="af4a36b464d672235cf91635f0816c95eac6128494e3d974929ae5ecd2e2df07ce"></a>_2NF&#160;</td><td class="fielddoc">
<p>Represnts the Second Normal form </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="af4a36b464d672235cf91635f0816c95ea0fbd388d0f5a49eea7bdeea548be03a3"></a>_3NF&#160;</td><td class="fielddoc">
<p>Represnts the Thirde Normal form </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="af4a36b464d672235cf91635f0816c95ea3e7f610cf0dcc22c6d1a3e654e7c16fa"></a>_BCNF&#160;</td><td class="fielddoc">
<p>Represnts the Boyce-Codd Normal form </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ae4e5fbc5744656e2949aa339a3a20809"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Relation::Relation </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="typedef_8h.html#aa234bdb39b1698c1d4955072cfb3195f">set_str</a> &amp;&#160;</td>
          <td class="paramname"><em>attribs</em> = <code>*(new&#160;<a class="el" href="typedef_8h.html#aa234bdb39b1698c1d4955072cfb3195f">set_str</a>())</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="typedef_8h.html#a49fdcf14d2faf54629fca98482b2dfb9">set_dep</a> &amp;&#160;</td>
          <td class="paramname"><em>dep</em> = <code>*(new&#160;<a class="el" href="typedef_8h.html#a49fdcf14d2faf54629fca98482b2dfb9">set_dep</a>())</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The parameterized <a class="el" href="class_relation.html" title="The Relation class that represents the relation entity. ">Relation</a> constructor with default values for attribute set and dependencies set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>is the string representing the name of the <a class="el" href="class_relation.html" title="The Relation class that represents the relation entity. ">Relation</a>. </td></tr>
    <tr><td class="paramname">attribs</td><td>is the set_str object that represents the attribute set for the newly constructed relation.It have default value as empty set_str object so the constructor can be used with different no of arguments the relation object will have an empty attribute set, if the attrib parameter is not provided. </td></tr>
    <tr><td class="paramname">is</td><td>the set_dep object that represents the dependency set for the newly constructed relation.It have default value as empty set_dep object so the constructor can be used with different no of arguments and the relation object will have an empty dependency set, if the dep parameter is not provided. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae36aedb2fbe0084795d577a58ae44a3b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Relation::Relation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_relation.html">Relation</a> &amp;&#160;</td>
          <td class="paramname"><em>orig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The copy constructor for the <a class="el" href="class_relation.html" title="The Relation class that represents the relation entity. ">Relation</a> class.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">orig</td><td>is the constant reference to the <a class="el" href="class_relation.html" title="The Relation class that represents the relation entity. ">Relation</a> object from which the data members used to initialize newly constructed object.</td></tr>
  </table>
  </dd>
</dl>
<p>The copy constructor uses all the data member from the parameter orig and initialize the data members of new object. </p>

</div>
</div>
<a class="anchor" id="ad8bc5c349f9d98b15972fd0b09f341cc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Relation::~Relation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The destructor for the <a class="el" href="class_relation.html" title="The Relation class that represents the relation entity. ">Relation</a> class.</p>
<p>The destructor will clear all the name, attribute set and dependency set of the relation object. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ab4fd894562cf6b53bf207e6b5c1093ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Relation::addAtributte </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A method to add a single attribute to the attribute set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>a constant string representing the single attribute to be added into the attribute set of the relation object.. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the new attribute is inserted, false otherwise.</dd></dl>
<p>The parameter str will be inserted if it is no already present in the attribute set. </p>

</div>
</div>
<a class="anchor" id="aeb703bd9672bba59a283c86d3d718e5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Relation::addAtributtes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="typedef_8h.html#aa234bdb39b1698c1d4955072cfb3195f">set_str</a> &amp;&#160;</td>
          <td class="paramname"><em>as</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A method to add multiple attributes to the attribute set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">as</td><td>is set_str object represent the attribute set to be added to the attribute set of the relation object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true at least one attribute from parameter set is inserted in the relation object attribute set, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="aba0be8b3cfe8d57a77ac0cf1bc2eee49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Relation::addDependencies </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="typedef_8h.html#a49fdcf14d2faf54629fca98482b2dfb9">set_dep</a> &amp;&#160;</td>
          <td class="paramname"><em>dep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>update</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A method to add multiple attributes to the attribute set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dep</td><td>set of dependencies to be added into the relation. </td></tr>
    <tr><td class="paramname">update</td><td>boolean parameter with default value false to indicate that whether to add the attribute if dependency contains the attribute which is not already present in the attribute set of the relation.</td></tr>
  </table>
  </dd>
</dl>
<p>Foe every dependency object from the parameter dep, the method <a class="el" href="class_relation.html#a9b15b6309a27f5621039ae7e375bea95">Relation::addDependency</a> will be called. </p>

</div>
</div>
<a class="anchor" id="a9b15b6309a27f5621039ae7e375bea95"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="typedef_8h.html#ab78cecb3657d8a4377c1f9e4dba8778c">itr_dep</a> Relation::addDependency </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="typedef_8h.html#aa234bdb39b1698c1d4955072cfb3195f">set_str</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="typedef_8h.html#aa234bdb39b1698c1d4955072cfb3195f">set_str</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>update</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A method to add a single dependency with explicitly specified lhs and rhs to the dependency set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>is string set representing the lhs side of the dependency. </td></tr>
    <tr><td class="paramname">rhs</td><td>is string set representing the rhs side of the dependency. </td></tr>
    <tr><td class="paramname">update</td><td>is boolean parameter with default value true. If the update value is true then all the attributes form lhs and rhs which are not part of the attribute set of the relation object will added to the attribute set first. No new attribute will be inserted into the relation attribute set if the update value is false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the dependency is added into the dependency set for the relation object, the iterator pointing to the newly added dependency object will be returned. If dependency is already present in the dependency set then the iterator pointing to the existing dependency object will be returned. If no dependency is added to the relation then the set::end for the dependency set will be returned.</dd></dl>
<p>All the the attributes from the rhs which are subset of lhs will be removed first and if the rhs is empty then the dependency will not be added to the relation. If the rhs is not empty then the new <a class="el" href="class_dependency.html" title="The Dependency class that represents the functional dependency of the relation using the attribute se...">Dependency</a> object will be created with lhs and modified rhs and the private method <a class="el" href="class_relation.html#a9b15b6309a27f5621039ae7e375bea95">Relation::addDependency</a> will be used with the update parameter value to insert the dependency into the dependency set. In this case the return value from <a class="el" href="class_relation.html#a9b15b6309a27f5621039ae7e375bea95">Relation::addDependency</a> will be returned back. </p>

</div>
</div>
<a class="anchor" id="ac1d9a658374a2e84f82e117949b0a2a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="typedef_8h.html#ab78cecb3657d8a4377c1f9e4dba8778c">itr_dep</a> Relation::addDependency </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_dependency.html">Dependency</a> &amp;&#160;</td>
          <td class="paramname"><em>dep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>update</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A method to add single dependency object to the dependency set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dep</td><td>A dependency object to be inserted into the dependency set of the relation. </td></tr>
    <tr><td class="paramname">update</td><td>is boolean parameter with default value true. If the update value is true then all the attributes form lhs and rhs which are not subset of attribute set of the relation, will added to the attribute set first. No new attribute will be inserted into the relation attribute set if the update value is false and the lhs and rhs contains some attributes which are not subset of relation attribute set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the dependency is added into the dependency set for the relation object, the iterator pointing to the newly added dependency object will be returned. If dependency is already present in the dependency set then the iterator pointing to the existing dependency object will be returned. If no dependency is added to the relation then the set::end for the dependency set will be returned.</dd></dl>
<p>If lhs and rhs are subset of the attribute set of the relation, then the dependency will added to the set. If the update option is ture and lhs or rhs are not subset of the attribute set then all the attributes from both lhs and rhs will be inserted into the relation attribute set first, then the dependency will be added. If update is false and the lhs is not subset of the attribute set of relation then no dependency will be added. If update is false and only rhs is not subset of relation attribute set then the only those attributes from the rhs which are part of the attribute set will be considered and all other attributes will be discarded from rhs and then the dependency will be inserted into the dependency set. Note that if dependency is inserted into the dependency set then private method Relation::reduceDependecy will be used to minimize the dependency set with same lhs values and the resultant position of the newly inserted dependency will be returned. </p>

</div>
</div>
<a class="anchor" id="ad2ac1a5f21fad67ea0d1370d653e2d67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Relation::clearAttributes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A method to clear the attribute set of the relation.</p>
<p>This method will clear all the attribute set and dependency set of the relation object. </p>

</div>
</div>
<a class="anchor" id="a3c7aa8f1df884462856e4a1b4e05658b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Relation::clearDependencies </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A method to clear the dependency set of the relation.</p>
<p>This method will clear all the dependency set of the relation object. </p>

</div>
</div>
<a class="anchor" id="af01e5bab69f13b1e1b80526de5594b0f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="typedef_8h.html#ae4f64e726e10cd561d68b42cf3a43e94">set_rel</a> Relation::decomposeNotPreserving </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>details</em> = <code>false</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A method to get the sub-relation set for the given relation object by using non FD preserving algorithm.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">details</td><td>a boolean parameter with default value false. If true the steps involved in the decomposition will be printed on standard output stream cout. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>set_rel object representing the set of decomposed sub-relations.</dd></dl>
<p>The method will use the FD-preserving decomposition algorithm to decompose the relation into the sub-relations and returns the set of such relations. All the decomposed sub relation will be in BCNF but it will not guarantees that all the original dependencies are preserved from dependencies found in all sub-relations. It uses the private static method Relation::decompose to perform the operation using recursive method. </p>

</div>
</div>
<a class="anchor" id="a37f89ba2927b02631761e541fde9ff91"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="typedef_8h.html#ae4f64e726e10cd561d68b42cf3a43e94">set_rel</a> Relation::decomposePreserving </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>details</em> = <code>false</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A method to get the sub-relation set for the given relation object by using FD preserving algorithm.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">details</td><td>a boolean parameter with default value false. If true the steps involved in the decomposition will be printed on standard output stream cout. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>set_rel object representing the set of decomposed sub-relations.</dd></dl>
<p>The method will use the FD-preserving decomposition algorithm to decompose the relation into the sub-relations and returns the set of such relations. The decomposed sub relation will have all the dependencies which can preserve the original dependency set. It will also ensures that each sub-relation is in at least 3NF. </p>

</div>
</div>
<a class="anchor" id="af67c3710d967393d2493c28aa6c84060"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="typedef_8h.html#ab78cecb3657d8a4377c1f9e4dba8778c">itr_dep</a> Relation::findDepLHS </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="typedef_8h.html#aa234bdb39b1698c1d4955072cfb3195f">set_str</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find dependency by specifying the lhs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>a string set parameter represents the lhs value to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The iterator position of the dependency object from the dependency set if the dependency is found with same lhs as the parameter. It returns the set::end iterator of the attribute set if the parameter is not equal to the any of dependency object's lhs form the dependency set of the relation. </dd></dl>

</div>
</div>
<a class="anchor" id="aaed04d808db08b522023c833c31b87ea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="typedef_8h.html#aa234bdb39b1698c1d4955072cfb3195f">set_str</a>&amp; Relation::getAttributes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A getter method to retrieve the attribute set of the relation. </p><dl class="section return"><dt>Returns</dt><dd>The constant reference of the set_str object that represents the attribute set of the relation object. </dd></dl>

</div>
</div>
<a class="anchor" id="ad59a21ce2b07154ba6f14ce19e94bf9e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="declaration_8h.html#a3205c77c822620c0f6dd4d42ccd70171">set_key</a> Relation::getCandidatekey </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A method to get all the candidate key set for the relation.</p>
<dl class="section return"><dt>Returns</dt><dd>set of keys object containing all the possible candidate keys for the relation.</dd></dl>
<p>The method will calculate all the possible candidate key for the relation object using current functional dependencies and the attributes. The single key can be considered as set of attributes which can derive all the attributes of the relation uisng the dependency set of the relation. </p>

</div>
</div>
<a class="anchor" id="a0cc1fd687a99bbe395b7a51b7080e91c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="typedef_8h.html#aa234bdb39b1698c1d4955072cfb3195f">set_str</a> Relation::getClosure </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="typedef_8h.html#aa234bdb39b1698c1d4955072cfb3195f">set_str</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A method to get the closure of the given attribute set using functional dependency set of the <a class="el" href="class_relation.html" title="The Relation class that represents the relation entity. ">Relation</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>is the set_str object that represents the set of attributes on which closure operation is to be performed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the set_str object containing all the attribute which are result of the closure operation.  The method will find out all the possible attributes which can be derived by the parameter lhs using dependency set of the relation. </dd></dl>

</div>
</div>
<a class="anchor" id="a569838107aebf43367d9c2c0dbc0d359"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="typedef_8h.html#a49fdcf14d2faf54629fca98482b2dfb9">set_dep</a>&amp; Relation::getDependencies </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A getter method to retrieve the dependency set of the relation. </p><dl class="section return"><dt>Returns</dt><dd>The constant reference of the set_dep object that represents the dependency set of the relation object. </dd></dl>

</div>
</div>
<a class="anchor" id="a5373e82dc8498648a6c75aa85f895bf4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="typedef_8h.html#a49fdcf14d2faf54629fca98482b2dfb9">set_dep</a> Relation::getMinimalCover </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>details</em> = <code>false</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A method to get the minimal cover dependency set for the all dependencies that belongs to the relation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">details</td><td>a boolean parameter with default value false. If true the steps involved in the finding minimal cover will be printed on standard output stream cout. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the set of dependency representing the minimal form of current functional dependencies of the relation object.</dd></dl>
<p>The method will use three different steps reduce lhs, reduce rhs and reduce rules by using private methods of the relation to get the minimal cover. </p>

</div>
</div>
<a class="anchor" id="a3f2630997cefbc28c0abce228033fe92"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string Relation::getName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A getter method to retrieve the name of the relation. </p><dl class="section return"><dt>Returns</dt><dd>The string representing the name of the relation. attribute set of the relation object. </dd></dl>

</div>
</div>
<a class="anchor" id="ad3db61785cf2aa64c5ac7451bdc1a1aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="typedef_8h.html#a49fdcf14d2faf54629fca98482b2dfb9">set_dep</a> Relation::getViolation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_relation.html#af4a36b464d672235cf91635f0816c95e">Relation::Normal</a> &amp;&#160;</td>
          <td class="paramname"><em>form</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A method to get dependency set that violates given normal form conditions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">form</td><td>represents the normal form from one of the <a class="el" href="class_relation.html#af4a36b464d672235cf91635f0816c95e">Relation::Normal</a> value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>set of dependency from dependencies of the relation object which violates the condition for the given normal form indicated by the parameter form.</dd></dl>
<p>It uses the functor object of <a class="el" href="struct_violation.html" title="A unary functor class used to test the dependency for the normal form violation. ">Violation</a> as predicate to find out the return value. </p>

</div>
</div>
<a class="anchor" id="ade40c2bc16bac827eaddca39b3b8964d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Relation::isDepAttribPresent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_dependency.html">Dependency</a> &amp;&#160;</td>
          <td class="paramname"><em>dep</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A method to check if all the attributes of the parameter dependency present in the attribute set of the relation object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dep</td><td>is a constant reference to the <a class="el" href="class_dependency.html" title="The Dependency class that represents the functional dependency of the relation using the attribute se...">Dependency</a> object for which the check is to be performed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all the attributes form the dependency lhs and rhs set are subset of the attribute set of the relation object, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a5356ab1275c3f1dd82ab0a267d1dfabc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Relation::isNormal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_relation.html#af4a36b464d672235cf91635f0816c95e">Relation::Normal</a> &amp;&#160;</td>
          <td class="paramname"><em>form</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A method to test normal form of the current <a class="el" href="class_relation.html" title="The Relation class that represents the relation entity. ">Relation</a> object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">form</td><td>is a <a class="el" href="class_relation.html#af4a36b464d672235cf91635f0816c95e">Relation::Normal</a> value represents the normal form for which the relation is to be tested. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the relation is in the normal form provided by the parameter, false otherwise.</dd></dl>
<p>The method will use the functor object of <a class="el" href="struct_violation.html" title="A unary functor class used to test the dependency for the normal form violation. ">Violation</a> class to find the any violation for the normal form for every dependency from dependency set. No violation means the relation is in given normal form. </p>

</div>
</div>
<a class="anchor" id="a0d877107afd23e2e412011959de27740"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Relation::isPartialkey </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="typedef_8h.html#aa234bdb39b1698c1d4955072cfb3195f">set_str</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A method to test if the given string set is the partial-key to the relation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>represents the attribute set which is to find out is partial key or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the parameter lhs is the partial, false otherwise.</dd></dl>
<p>The lhs is considered as the partial key if it is subset of at least one candidate key from candidate key set. </p>

</div>
</div>
<a class="anchor" id="ae9ae78eb66d2950fea16dad1c21e62cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Relation::isPrime </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="typedef_8h.html#aa234bdb39b1698c1d4955072cfb3195f">set_str</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A method to test if the given string set is belong to the prime attribute set of the relation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>represents the attribute set which is to find out is prime or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the parameter str is the subset of prime attributes, false otherwise.</dd></dl>
<p>The attribute is considered as prime attribute if it belongs to any one of the candidate key. If parameter is sub set of all the prime attribute then true value is returned. </p>

</div>
</div>
<a class="anchor" id="a4c810ab6573fdd594a84e664bc21794a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Relation::isSuperkey </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="typedef_8h.html#aa234bdb39b1698c1d4955072cfb3195f">set_str</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A method to test if the given string set is the super-key to the relation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>represents the attribute set to find out is supekey or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the parameter lhs is the superkey, false otherwise.</dd></dl>
<p>The lhs is considered as the superkey if it is superset of at least one candidate key from candidate key set. </p>

</div>
</div>
<a class="anchor" id="af3c884586ee349da4f3c3e9a55d94f97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Relation::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_relation.html">Relation</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A overloaded relational operator to check inequality between two relation objects.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">right</td><td>the rhs relation object for the comparison operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if current relation object is not equal to the parameter right, false otherwise.</dd></dl>
<p>This method reuses the <a class="el" href="class_relation.html#af3c884586ee349da4f3c3e9a55d94f97">Relation::operator !=</a>. </p>

</div>
</div>
<a class="anchor" id="af5dc18e0b5cb8937f87f1cb8593192e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Relation::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_relation.html">Relation</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A overloaded relational operator to check less than or inequality between two relation objects.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">right</td><td>the rhs relation object for the comparison operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if current relation object is logically lesser than the parameter right, false otherwise.</dd></dl>
<p>The relation will use the attribute set size and dependency set size to determine the logical lesser relation object. In case of equal attribute set and dependency set the name will be used to determine the result. In case of equal attribute size and but the not equal attribute set, the <a class="el" href="classsetstr__compare.html#a13434772bcc27130c092e34bad37b101">setstr_compare::less</a> function will be used to compare the attribute sets. In case of the equal dependency set size but not equal dependency set, the overloaded <a class="el" href="class_dependency.html#a78821e0db3f417a24b728d38e7d8ff47">Dependency::operator &lt;</a> will be used to determine the lesser dependency set between two relation objects. </p>

</div>
</div>
<a class="anchor" id="aaceeb923c5623a9f22cfb3f161b8a26c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Relation::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_relation.html">Relation</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A overloaded relational operator to check less than or equal to inequality between two relation objects.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">right</td><td>the rhs relation object for the comparison operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if current relation object is logically lesser than or equal to the parameter right, false otherwise.</dd></dl>
<p>This method reuses the <a class="el" href="class_relation.html#af5dc18e0b5cb8937f87f1cb8593192e3">Relation::operator &lt;</a> and Relation::operator =. </p>

</div>
</div>
<a class="anchor" id="a7a4c2acb958780bbf6fc5a52a456a9f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Relation::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_relation.html">Relation</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A overloaded relational operator to check equality between two relation objects.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">right</td><td>the rhs relation object for the comparison operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if both relation are equla, false otherwise.</dd></dl>
<p>The relation objects will be considered equal if the name of both relation is equal and the attribute set &amp; dependency set are equal. </p>

</div>
</div>
<a class="anchor" id="a6a234c8dfd0875f60b22799c587d46e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Relation::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_relation.html">Relation</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A overloaded relational operator to check greater than or inequality between two relation objects.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">right</td><td>the rhs relation object for the comparison operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if current relation object is logically lesser than the parameter right, false otherwise.</dd></dl>
<p>This method reuses the <a class="el" href="class_relation.html#af5dc18e0b5cb8937f87f1cb8593192e3">Relation::operator &lt;</a>. </p>

</div>
</div>
<a class="anchor" id="a3c7507f98a726b72f921f6ec940a0a3f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Relation::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_relation.html">Relation</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A overloaded relational operator to check greater than or equal to inequality between two relation objects.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">right</td><td>the rhs relation object for the comparison operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if current relation object is logically greater than or equal to the parameter right, false otherwise.</dd></dl>
<p>This method reuses the <a class="el" href="class_relation.html#a6a234c8dfd0875f60b22799c587d46e0">Relation::operator &gt;</a> and Relation::operator =. </p>

</div>
</div>
<a class="anchor" id="a919e9f07b7f8bb2f1119b25f301d9f1c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Relation::removeAtributte </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A method to remove a single attribute from the attribute set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>a constant string representing the single attribute to be removed from the attribute set of the relation object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if attribute is removed from the set, false otherwise.</dd></dl>
<p>If the attribute is not found in the attribute set of the relation object then no attribute will be removed. If it is found in the relation then the attribute will be removed. The dependency set will be searched to find out dependencies which contains the removed attribute. If the attribute present in lhs part of the dependency the entire dependency will be removed from dependency set. If the attribute is found only in rhs set of the dependency, then the attribute will be removed from rhs as well. </p>

</div>
</div>
<a class="anchor" id="abf6483df38b205939024c7f4e93bf890"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Relation::removeDependency </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="typedef_8h.html#aa234bdb39b1698c1d4955072cfb3195f">set_str</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="typedef_8h.html#aa234bdb39b1698c1d4955072cfb3195f">set_str</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A method to remove a single dependency from the dependency set by providing separate set_str to represent the custom lhs and rhs of the dependency.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>is string set representing the lhs side of the dependency. </td></tr>
    <tr><td class="paramname">rhs</td><td>is string set representing the rhs side of the dependency. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the dependency is found and removed from the dependency set false otherwise.</dd></dl>
<p>It creates the temporary <a class="el" href="class_dependency.html" title="The Dependency class that represents the functional dependency of the relation using the attribute se...">Dependency</a> object from lhs and rhs and then uses private method <a class="el" href="class_relation.html#abf6483df38b205939024c7f4e93bf890">Relation::removeDependency</a> to remove it from the dependency set. </p>

</div>
</div>
<a class="anchor" id="a1cee25dae94b1bb7ed1ce12592fbbd8b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Relation::removeDependency </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_dependency.html">Dependency</a> &amp;&#160;</td>
          <td class="paramname"><em>dep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A method to remove a single dependency from the dependency set by providing constant reference to the dependency object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dep</td><td>constant reference to the dependency object to be removed from the dependency set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the dependency is found and removed, false otherwise.</dd></dl>
<p>This method will first finds the exact match for the dependency by finding the dependency object from the dependency set which has same lhs and rhs as parameter dep. If no such dependency is found, then the dependency with the same lhs will be searched. If found then the only the rhs part of parameter dep will be removed from the from the matching result. If no dependency is found to remove or modify then the false value will be returned. </p>

</div>
</div>
<a class="anchor" id="ae98924c3d4ddf1e19a23403fcb35afe0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Relation::setName </td>
          <td>(</td>
          <td class="paramtype">const string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A setter method to set the name of the relation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>a string parameter indicates the new name of the relation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="relation_8h_source.html">relation.h</a></li>
<li><a class="el" href="relation_8cc.html">relation.cc</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
